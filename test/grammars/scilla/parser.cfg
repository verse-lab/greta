=s=
start
=nt=
with_constraint
type_term
type_annot
typ
transition
tconstr
targ
t_map_value_args
t_map_value_allow_targs_deprecated
t_map_value_allow_targs
t_map_value
t_map_key
stmts_term
stmts
stmt_pm_clause
stmt
simple_exp
sident
sid
separated_nonempty_list(SEMICOLON,stmt)
separated_nonempty_list(SEMICOLON,msg_entry)
separated_nonempty_list(COMMA,sident)
separated_nonempty_list(COMMA,param_pair)
separated_nonempty_list(COMMA,address_type_field)
scid
return_type
remote_fetch_stmt
procedure
pattern
param_pair
option(sid)
option(return_type)
option(library)
option(ctargs)
option(bcfetch_args)
nonempty_list(tconstr)
nonempty_list(targ)
nonempty_list(t_map_value_args)
nonempty_list(sident)
nonempty_list(map_access)
msg_entry
map_access
loption(separated_nonempty_list(SEMICOLON,stmt))
loption(separated_nonempty_list(SEMICOLON,msg_entry))
loption(separated_nonempty_list(COMMA,param_pair))
loption(separated_nonempty_list(COMMA,address_type_field))
lmodule
lit
list(targ)
list(stmt_pm_clause)
list(sident)
list(libentry)
list(importname)
list(field)
list(exp_pm_clause)
list(component)
list(arg_pattern)
library
libentry
imports
importname
id_with_typ
field
exp_term
exp_pm_clause
exp
ctargs
contract
component_params
component_id
component_body
component
cmodule
builtin_args
bcfetch_args
atomic_exp
arg_pattern
address_type_field
address_typ
=t=
WITH
UNDERSCORE
TYPE
TRY
TRANSITION
TID
THROW
TFUN
TARROW
STRING
SPID
SEND
SEMICOLON
SCILLA_VERSION
RSQB
RPAREN
REMOTEFETCH
RBRACE
PROCEDURE
PERIOD
OF
NUMLIT
MATCH
MAP
LSQB
LPAREN
LIBRARY
LET
LBRACE
IN
IMPORT
ID
HEXLIT
FUN
FORALL
FIELD
FETCH
EXISTS
EVENT
EQ
EOF
END
EMP
DELETE
CONTRACT
COMMA
COLON
CID
CATCH
BUILTIN
BAR
AT
ASSIGN
AS
ARROW
AND
ACCEPT
=p=
start -> cmodule
start -> exp_term
start -> lmodule
start -> stmts_term
start -> type_term
with_constraint -> WITH exp ARROW
type_term -> typ EOF
type_annot -> COLON typ
typ -> scid list(targ)
typ -> MAP t_map_key t_map_value
typ -> typ TARROW typ
typ -> LPAREN typ RPAREN
typ -> address_typ
typ -> FORALL TID PERIOD typ
typ -> TID
transition -> TRANSITION component_id component_params component_body
tconstr -> BAR CID
tconstr -> BAR CID OF nonempty_list(targ)
targ -> LPAREN typ RPAREN
targ -> scid
targ -> TID
targ -> address_typ
targ -> MAP t_map_key t_map_value
t_map_value_args -> LPAREN t_map_value_allow_targs RPAREN
t_map_value_args -> scid
t_map_value_args -> MAP t_map_key t_map_value
t_map_value_allow_targs_deprecated -> scid nonempty_list(t_map_value_args)
t_map_value_allow_targs -> scid nonempty_list(t_map_value_args)
t_map_value_allow_targs -> t_map_value
t_map_value -> scid
t_map_value -> MAP t_map_key t_map_value
t_map_value -> LPAREN t_map_value_allow_targs RPAREN
t_map_value -> address_typ
t_map_value -> t_map_value_allow_targs_deprecated
t_map_key -> scid
t_map_key -> LPAREN scid RPAREN
t_map_key -> LPAREN address_typ RPAREN
t_map_key -> address_typ
stmts_term -> stmts EOF
stmts -> loption(separated_nonempty_list(SEMICOLON,stmt))
stmt_pm_clause -> BAR pattern ARROW loption(separated_nonempty_list(SEMICOLON,stmt))
stmt -> ID FETCH sid
stmt -> remote_fetch_stmt
stmt -> ID ASSIGN sid
stmt -> ID EQ exp
stmt -> ID FETCH AND CID option(bcfetch_args)
stmt -> ID FETCH ID nonempty_list(map_access)
stmt -> ID FETCH EXISTS ID nonempty_list(map_access)
stmt -> ID nonempty_list(map_access) ASSIGN sid
stmt -> DELETE ID nonempty_list(map_access)
stmt -> ACCEPT
stmt -> SPID ASSIGN sid
stmt -> SEND sid
stmt -> EVENT sid
stmt -> THROW option(sid)
stmt -> MATCH sid WITH list(stmt_pm_clause) END
stmt -> component_id list(sident)
stmt -> FORALL sident component_id
simple_exp -> LET ID EQ simple_exp IN exp
simple_exp -> LET ID type_annot EQ simple_exp IN exp
simple_exp -> FUN LPAREN id_with_typ RPAREN ARROW exp
simple_exp -> sid nonempty_list(sident)
simple_exp -> atomic_exp
simple_exp -> BUILTIN ID option(ctargs) builtin_args
simple_exp -> LBRACE loption(separated_nonempty_list(SEMICOLON,msg_entry)) RBRACE
simple_exp -> scid option(ctargs) list(sident)
simple_exp -> MATCH sid WITH list(exp_pm_clause) END
simple_exp -> TFUN TID ARROW exp
simple_exp -> AT sid nonempty_list(targ)
sident -> ID
sident -> SPID
sident -> CID PERIOD ID
sid -> ID
sid -> SPID
sid -> CID PERIOD ID
separated_nonempty_list(SEMICOLON,stmt) -> stmt
separated_nonempty_list(SEMICOLON,stmt) -> stmt SEMICOLON separated_nonempty_list(SEMICOLON,stmt)
separated_nonempty_list(SEMICOLON,msg_entry) -> msg_entry
separated_nonempty_list(SEMICOLON,msg_entry) -> msg_entry SEMICOLON separated_nonempty_list(SEMICOLON,msg_entry)
separated_nonempty_list(COMMA,sident) -> sident
separated_nonempty_list(COMMA,sident) -> sident COMMA separated_nonempty_list(COMMA,sident)
separated_nonempty_list(COMMA,param_pair) -> param_pair
separated_nonempty_list(COMMA,param_pair) -> param_pair COMMA separated_nonempty_list(COMMA,param_pair)
separated_nonempty_list(COMMA,address_type_field) -> address_type_field
separated_nonempty_list(COMMA,address_type_field) -> address_type_field COMMA separated_nonempty_list(COMMA,address_type_field)
scid -> CID
scid -> CID PERIOD CID
scid -> HEXLIT PERIOD CID
return_type -> COLON typ
remote_fetch_stmt -> ID FETCH AND ID PERIOD sident
remote_fetch_stmt -> ID FETCH AND SPID PERIOD SPID
remote_fetch_stmt -> ID FETCH AND ID PERIOD LPAREN sident RPAREN
remote_fetch_stmt -> ID FETCH AND ID PERIOD ID nonempty_list(map_access)
remote_fetch_stmt -> ID FETCH AND EXISTS ID PERIOD ID nonempty_list(map_access)
remote_fetch_stmt -> ID FETCH AND sident AS address_typ
procedure -> PROCEDURE component_id component_params option(return_type) component_body
pattern -> UNDERSCORE
pattern -> ID
pattern -> scid list(arg_pattern)
param_pair -> id_with_typ
option(sid) ->
option(sid) -> sid
option(return_type) ->
option(return_type) -> return_type
option(library) ->
option(library) -> library
option(ctargs) ->
option(ctargs) -> ctargs
option(bcfetch_args) ->
option(bcfetch_args) -> bcfetch_args
nonempty_list(tconstr) -> tconstr
nonempty_list(tconstr) -> tconstr nonempty_list(tconstr)
nonempty_list(targ) -> targ
nonempty_list(targ) -> targ nonempty_list(targ)
nonempty_list(t_map_value_args) -> t_map_value_args
nonempty_list(t_map_value_args) -> t_map_value_args nonempty_list(t_map_value_args)
nonempty_list(sident) -> sident
nonempty_list(sident) -> sident nonempty_list(sident)
nonempty_list(map_access) -> map_access
nonempty_list(map_access) -> map_access nonempty_list(map_access)
msg_entry -> sid COLON lit
msg_entry -> sid COLON sid
map_access -> LSQB sident RSQB
loption(separated_nonempty_list(SEMICOLON,stmt)) ->
loption(separated_nonempty_list(SEMICOLON,stmt)) -> separated_nonempty_list(SEMICOLON,stmt)
loption(separated_nonempty_list(SEMICOLON,msg_entry)) ->
loption(separated_nonempty_list(SEMICOLON,msg_entry)) -> separated_nonempty_list(SEMICOLON,msg_entry)
loption(separated_nonempty_list(COMMA,param_pair)) ->
loption(separated_nonempty_list(COMMA,param_pair)) -> separated_nonempty_list(COMMA,param_pair)
loption(separated_nonempty_list(COMMA,address_type_field)) ->
loption(separated_nonempty_list(COMMA,address_type_field)) -> separated_nonempty_list(COMMA,address_type_field)
lmodule -> SCILLA_VERSION NUMLIT imports library EOF
lit -> CID NUMLIT
lit -> HEXLIT
lit -> STRING
lit -> EMP t_map_key t_map_value
list(targ) ->
list(targ) -> targ list(targ)
list(stmt_pm_clause) ->
list(stmt_pm_clause) -> stmt_pm_clause list(stmt_pm_clause)
list(sident) ->
list(sident) -> sident list(sident)
list(libentry) ->
list(libentry) -> libentry list(libentry)
list(importname) ->
list(importname) -> importname list(importname)
list(field) ->
list(field) -> field list(field)
list(exp_pm_clause) ->
list(exp_pm_clause) -> exp_pm_clause list(exp_pm_clause)
list(component) ->
list(component) -> component list(component)
list(arg_pattern) ->
list(arg_pattern) -> arg_pattern list(arg_pattern)
library -> LIBRARY CID list(libentry)
libentry -> LET ID EQ exp
libentry -> LET ID type_annot EQ exp
libentry -> TYPE CID
libentry -> TYPE CID EQ nonempty_list(tconstr)
imports -> IMPORT list(importname)
imports ->
importname -> CID
importname -> CID AS CID
id_with_typ -> ID type_annot
field -> FIELD id_with_typ EQ exp
exp_term -> exp EOF
exp_pm_clause -> BAR pattern ARROW exp
exp -> simple_exp
ctargs -> LBRACE list(targ) RBRACE
contract -> CONTRACT CID LPAREN loption(separated_nonempty_list(COMMA,param_pair)) RPAREN list(field) list(component)
contract -> CONTRACT CID LPAREN loption(separated_nonempty_list(COMMA,param_pair)) RPAREN with_constraint list(field) list(component)
component_params -> LPAREN loption(separated_nonempty_list(COMMA,param_pair)) RPAREN
component_id -> CID
component_id -> ID
component_body -> stmts END
component -> transition
component -> procedure
cmodule -> SCILLA_VERSION NUMLIT imports option(library) contract EOF
builtin_args -> nonempty_list(sident)
builtin_args -> LPAREN RPAREN
bcfetch_args -> LPAREN separated_nonempty_list(COMMA,sident) RPAREN
atomic_exp -> sid
atomic_exp -> lit
arg_pattern -> UNDERSCORE
arg_pattern -> ID
arg_pattern -> scid
arg_pattern -> LPAREN pattern RPAREN
address_type_field -> FIELD id_with_typ
address_typ -> CID WITH END
address_typ -> CID WITH CONTRACT loption(separated_nonempty_list(COMMA,address_type_field)) END
address_typ -> CID WITH LIBRARY END
address_typ -> CID WITH SPID END
address_typ -> CID WITH CONTRACT LPAREN loption(separated_nonempty_list(COMMA,param_pair)) RPAREN loption(separated_nonempty_list(COMMA,address_type_field)) END
